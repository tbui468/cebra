//mini-interpreter to test cebra capabilities

//***********source************
src := "2 + 4 * 2 - 4"

//************lexer************
TokenType :: enum {
    default
    number
    plus
    minus
    star
    slash
    left_paren
    right_paren
    eof
}

Token :: struct {
    type := TokenType.default
    literal := ""
}

index := 0
current_char := ""

is_digit :: (char: string) -> bool {
    -> char == "0" or
       char == "1" or
       char == "2" or
       char == "3" or
       char == "4" or
       char == "5" or
       char == "6" or
       char == "7" or
       char == "8" or
       char == "9"
}

is_whitespace :: (char: string) -> bool {
    -> char == " "
}

peek :: (src: string, index: int, fun: (string) -> bool) -> bool {
    if index >= src.size {
        -> false
    } 
    -> fun(src[index])
}

next_char := () -> bool {
    if index >= src.size {
        -> false
    }
    current_char = src[index]
    index = index + 1
    -> true
}

next_token := () -> Token {

    while peek(src, index, is_whitespace) {
        next_char()
    }

    if next_char() {
        token := Token()
        token.literal = current_char
        if current_char == "+" {
            token.type = TokenType.plus
            -> token
            //-> Token(TokenType.plus, "+") //would like to be able to do this
        } 
        if current_char == "-" {
            token.type = TokenType.minus
            -> token
        }
        if current_char == "*" {
            token.type = TokenType.star
            -> token
        }
        if current_char == "*" {
            token.type = TokenType.slash
            -> token
        }
        if current_char == "(" {
            token.type = TokenType.left_paren
            -> token
        }
        if current_char == ")" {
            token.type = TokenType.right_paren
            -> token
        }
        //if number
        num_string := current_char
        while peek(src, index, is_digit) {
            next_char()
            num_string = num_string + current_char 
        }
        token.type = TokenType.number
        token.literal = num_string
        -> token 
    } else {
        token := Token()
        token.type = TokenType.eof
        -> token
    }
}

//***********AST************

Expr :: struct {
    token: Token = nil
}

PrimaryExpr :: struct < Expr { 
}


BinaryExpr :: struct < Expr { 
    left: Expr = nil
    right: Expr = nil
}

make_primary_expr :: (token: Token) -> Expr {
    primary := PrimaryExpr()
    primary.token = token
    -> primary as Expr
}

make_binary_expr :: (token: Token, left: Expr, right: Expr) -> Expr {
    binary := BinaryExpr()
    binary.token = token
    binary.left = left
    binary.right = right
    -> binary as Expr
}

//*********parser***********
previous_token: Token = nil
current_token := next_token()

match := (type: TokenType) -> bool {
    if type == current_token.type {
        previous_token = current_token
        current_token = next_token()
        -> true
    } 
    -> false
}

parse_primary :: (match: (TokenType) -> bool, prev: () -> Token) -> Expr {
    if match(TokenType.number) {
        -> make_primary_expr(prev())
    }

    if match(TokenType.left_paren) {
        expr := parse_expression(match, prev)
        match(TokenType.right_paren)
        -> expr
    }
}

parse_factor :: (match: (TokenType) -> bool, prev: () -> Token) -> Expr {
    left := parse_primary(match, prev)

    while match(TokenType.star) or match(TokenType.slash) {
        left = make_binary_expr(prev(), left, parse_primary(match, prev))
    }

    -> left
}

parse_term :: (match: (TokenType) -> bool, prev: () -> Token) -> Expr {
    left := parse_factor(match, prev)

    while match(TokenType.plus) or match(TokenType.minus) {
        left = make_binary_expr(prev(), left, parse_factor(match, prev))
    }

    -> left
}

parse_expression :: (match: (TokenType) -> bool, prev: () -> Token) -> Expr {
    -> parse_term(match, prev)
}

string_expr :: (expr: Expr) -> string {
    if expr as PrimaryExpr != nil {
        -> " " + expr.token.literal + " "
    }

    if expr as BinaryExpr != nil {
        b := expr as BinaryExpr
        -> "( " + expr.token.literal + " " + string_expr(b.left) + string_expr(b.right) + " )"
    }
}

//**********evaluator*******
evaluate_node :: (expr: Expr) -> int {
    if expr as PrimaryExpr != nil {
        -> (expr as PrimaryExpr).token.literal as int
    }

    if expr as BinaryExpr != nil {
        b := expr as BinaryExpr
        left := evaluate_node(b.left)
        right := evaluate_node(b.right)
        if b.token.literal == "+" {
            -> left + right
        }
        if b.token.literal == "-" {
            -> left - right
        }
        if b.token.literal == "*" {
            -> left * right
        }
        if b.token.literal == "/" {
            -> left / right
        }
    }
}

//*********driver***********
//root := parse_expression(match, () -> Token { -> previous_token })
//print(evaluate_node(root))

src = "3 - 5 * 10 + 50 * 1"
index = 0
current_char = ""
previous_token = nil
current_token = next_token()

root := parse_expression(match, () -> token { -> previous_token })
print(string_expr(root))
print(evaluate_node(root))
