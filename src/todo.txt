DOCUMENTATION:
    Look at how Nystrom design docs for Wren
    The embedded compiler/vm in browser is neat

ADDING FEATURES:
    Add correctness tests for new features
    Pass all correctness.cbr tests
    Check that ALL memory is freed if GC is called at end of main()
    TODO: need a way to test type checking

IMPLEMENTATION:


        free_sig(struct Sig*) should now just free itself - any other sigs
        it owns will be on the linked list and be freed later (or already)

        Add new Sig* to mm.signatures

        make sure all correctness tests are passed, and DEBUG_STRESS_GC works
        and all bytes allocated are at 0 

        GOAL:
        The goal here is to have a way to store Class Sigs in the compiler so
        that any subsequent instances of that class can be properly 
        typechecked...

        Since we want to use the same strings in both SigClass
        and properties in ObjClass, we should intern strings.  Implement
        this next.  Check by using the same string multiple times and see
        if we only have one ObjString* in the mm.objects linked list.
        
        was planning to add a table of Sigs (wrapped in Value) of type
        SigClass.  This makes it easy to add to locals, but requires
        a lot of management to clear.  Free the value sigs (when are the 
        sigs cleared again?).  Free the table.  But don't free the 
        keys, ObjString*.  Let the GC take care of that.

        Added sig_type to union in Value.h, and a to_sig(struct Sig* sig)
        to value.h/c, but not sure this is a good idea.  

        problem: if we use a table of Sigs in SigClass, we will
        need to clear the table properly - before clearing table,
        need to clear the Sig* values, but NOT the ObjString*.  But the
        we need to add the locals in compiler to roots...this is confusing.

        Parser should create the correct SigClass* for DeclClass and
            then put it inside the AST node.  The compiler can just
            then read out the Sig* and add it to the locals along with
            the Token name.  SigClass should hold a table of Sig* (wrapped
            in a Value) of each property and method with their names
            as keys.  Duck typing.  create duck_type(Sig* sub, Sig* super)
            to see if sub is a subset of super.

        Intern strings before implementing ObjInstance since we will
            need a lot of repeat strings.  Need to think about weak 
            references and the GC.  Reread that section in GC about
            bugs with the GC.  Will also need a way to delete entries
            in a hash table since we need to delete dangling pointer
            when the key (no value in interned strings table) of
            the strings table is marked.  

        For ObjInstance, just find the correct class and copy
            the table over (ObjString* can be just a pointer copy, but
            Value should be a deep copy).  Might be a good idea to intern 
            strings before this.  Have VM (or Memory Manager) keep a Table of
            ObjString*, and reuse them

        Inheritance syntax and implementation

    Does NODE_DECl_VAR only for primitive types, or is it for functions/classes too?

    How about assigning functions to other functions?
        I don't think we support this right now:
        my_fun: () -> = other_fun

    Allow shorthand for declaration types:
        a := 1
        b := "dogg"
        c := () -> int {
            -> 3
        }
        Dog := class {
            name := "Mittens"
        }

    Clear up the warnings (especially with switch statements)

    String Interning

    When a function returns, it closes any upvalues, but we don't
        see the call to OP_CLOSE_UPVALUE - need to add more instructions to
        disassemble chunk OR somehow make returning from a function call
        OP_CLOSE_UPVALUE for clarity.  Is there any situation where
        OP_CLOSE_UPVALUE actually gets called (rather than OP_RETURN 
        just doing all the work?)

    in compiler, CALL and CASCADE CALL share a lot of code - pull that into a function

    Native functions - start with clock() for measuring time
        should have an OP_CALL_NATIVE code

    Having to call free_sig on almost all signatures in compile_node is a bit much
      and super prone to errors.  How about putting all Sig* into a list upon
      creation, and then just free that list when the compilation process is over?
        this is similar to how we deal with freeing Objects with the GC

    Implement deleting from hash table - need to use tombstones

    Intern strings - create a "strings" table in vm

    Test Edge cases by writing toy programs - save these programs as correctness tests

    Stress test by writing script to load nyc_subway data - compare runtime to python pandas

    Write benchmarking code to use with chrome://tracing to find hotspots

    Why are if /else so much slower than just if (think of the fibonacci example


StatementList should be DeclList - all programs are a list of declarations
  decl - classDecl | funDecl | varDecl | stmt
      leave no effect on the stack
  stmt - exprStmt | forStmt | ifStmt | printStmt | returnStmt | whileStmt | block
      exprStmt are expressions where the result is discarded (pop the stack)
  expr - Literal | Unary | Binary | SetVar | GetVar
      push one value on the stack


