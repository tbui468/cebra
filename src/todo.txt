DOCUMENTATION:
    Look at how Nystrom design docs for Wren
    The embedded compiler/vm in browser is neat

IMPLEMENTATION:

    Problem with sweep() was that ObjFunction allocates memory twice in constructor -
        once for ObjFunction itself and once for chunk, which it owns.  This
        triggers the GC right inside the make_function() function before it 
        is added to a root (cc/vm->stack) but after it is added to mm.objects - so
        it's unmarked and gets freed.  I just moved adding it to the mm.objects linked
        list to the end of the function, but that's not really robust.

        How can we prevent problems like this in the future?  The goal is to preserve
            a new object we create until it can be safely stored in a reachable root...

    Complete trace_references() in memory.c.   See notes in function stub for more info.
        Do I want to include ObjString for functions to track names?
        Not until needed.

    Read when to collect garbage to see how often GC should be called

    Read GC bugs to make sure I don't miss any small details that Nystrom caught

    Redo class and instances
        OLD NOTES: 
        Get NODE_CLASS working with new defs table - in call frames
          should just need to use OP_SET/GET_DEF since they all use Values

        OP_INSTANCE in vm.c needs to be completed - look at notes in vm.c OP_INSTANCE
         basic problem: how to go from ObjClass -> Table necessary for instance?

    Clear up the warnings (especially with switch statements) before doing garbage collection

    in compiler, CALL and CASCADE CALL share a lot of code - pull that into a function

    Native functions - start with clock() for measuring time

    Having to call free_sig on almost all signatures in compile_node is a bit much
      and super prone to errors

    Implement deleting from hash table - need to use tombstones

    Intern strings - create a "strings" table in vm

    Test Edge cases by writing toy programs - save these programs as correctness tests

    Stress test by writing script to load nyc_subway data - compare runtime to python pandas

    Write benchmarking code to use with chrome://tracing to find hotspots

    Why are if /else so much slower than just if (think of the fibonacci example


StatementList should be DeclList - all programs are a list of declarations
  decl - classDecl | funDecl | varDecl | stmt
      leave no effect on the stack
  stmt - exprStmt | forStmt | ifStmt | printStmt | returnStmt | whileStmt | block
      exprStmt are expressions where the result is discarded (pop the stack)
  expr - Literal | Unary | Binary | SetVar | GetVar
      push one value on the stack


