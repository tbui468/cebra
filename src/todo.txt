Syntax highlighter:
    Push update to the marketplace - fixed typo with function colors not showing

Documentation:
    Html/Css is all fucked up in Chrome but fine in Firefox

    Update build/download instructions

    Look at GifTuna website for simple but effective layout

    Include language specification, eg:
        VarDecl     = "var" ( VarSpec | "(" { VarSpec ";" } ")" ) .
        VarSpec     = IdentifierList ( Type [ "=" ExpressionList ] | "=" ExpressionList ) 

    Clean up colors to make it more simple and clean.

    Update sections titles to match current status

    Update section on how to download/build from source and VSCode syntax highlighter

    Consider looking at Nystrom's Wren to see how he put the interpreter in the browser

    Maybe look into posting it on handmade network/reddit...
        
    Look at Odin-lang for reference for docs
        could just have sample code user can look at rather than an actual interactive panel

Implementation:

    SetVar currently only emits index of the variable to set to the top of the stack
        include an index down the stack to set to

    Add Sequence AST node and integrate new recursive parsing algorithms for parsing sequences - see next two notes sections:
        - Create Sequence node and integrate into parser/compiler - include sequence length checks
              in compiler, compile all right-hand-sides sequentially, and then the left hand sides
                check that code compiles and runs
        - Disallow sequence within sequences, and combine parse_expressions functions into one
                check that code compiles and runs
        - Declarations are NOT expressions - allowing them to be expressions would trap other items on the stack
            or knock them off the stack - all declarations should NOT return a value
            if a: bool = 22 > 242 { }
            if a = 23 > 242 { } //this is find if a a bool

        Don't allow  Sequences within sequences (so parse a single expression at a time
            x, y, z = a := 1, 3, 2 //will be parsed as x = a := 1, y = 3, and z = 2
            if a function with multiple returns is called, the return counts will be checked at runtime

        See these notes in parser.c too.  This also simplifies our parser since we don't need to have
            two parse_expression() functions anymore, and assignment() doesn't need the expected parameter
            since we check that in the compiler now.
                TODO: parse with or() here and manually check for ',' to prevent a sequence within sequence
                parse until ':=' or '=' or non ',' since we don't know how many will exists if functions with multiple
                returns are included
        
        1. For assignment, multiassignment from multiple returns might be tricky if we also allow arbitrary number in the 
            sequence.  We don't know the number of returns in a closure until compile time, so we simpled can't reverse
            the lhs of the assignments.

            One solution: have the function still compile the returns in order from left to right, but when returning
                we know how many returns there are - pop the returns into a temp stack, and then pop them back into the 
                vm stack so that the returns are in reverse order (and correct order for the declarations and assignments)
                ..but then we still don't know a

                One solution to that problem: we know that all statements will either be a var declaration or one of the three
                    assignments.  Make a new Sequence ast node that holds a list of declarations/assignments with NULL right sides, 
                    and a second list of all right side expressions.  At compile time, compile ALL the right sides in sequence and
                    then check if the sum of values on the stack is equal to the declarations/assignments in the first list. 
                    Then compile the first list in REVERSE order so that they line up with the elements in the stack.  Make sure
                    to put in NULL checks so that if the right hand side is null, declaration/assignment nodes just assign to top
                    of the stack.  
                    Will also need to think about how /when to pop the stack...
                    Note: this means that in sequences, all right hand side expressions are evaluated before they are assigned
                    at the end.  This should be mentioned in the docs.

        2. Is sequential assignment too ambiguous?  
            Sequences need to be right associative, so we simply can't loop - 
            it needs to be called recursively for every := or = that follows:

            If sequence (parse 1 expression and check if followed by comma), then call
            parse_sequence_right(lhs).  

                struct Sequence* s = parse_sequence()
                if next is := or = {
                    check that all nodes are GetVar, GetElement, GetProp, or DeclVar with right == NULL
                    result = parse_sequence_right(s)
                }

                parse_sequence_right :: (lhs) -> struct Sequence* {
                    rhs = parse right side separated by commas
                    if after parsing right is := or = {
                        check that ALL right nodes are GetVar, GetElement, GetProp or DeclVar with right == NULL
                        -> parse_sequence_right(right)
                    } else {
                        -> make_set_sequence(lhs, rhs) //base case
                    }
                }
           
                a, b = c = 23, 4 

            Have the parser check for errors here - see comments in pseudo code above

    Need to finish implemenation of multiple returns:
        See @ symbol in compiler to see locations where we're just grabbing the first TypeArray type to make
            the program compile - need to implement multireturns next.  Multiple returns only occur for function 
            calls, so we should be able to limit the changes we have to make in the code to those only...
            Note: this can't be correct/tested until the new Sequence AST node is implemented

    Idea: have two types for multiple types: 
        TypeSequence is for function parameters, returns and Sequence AST nodes.  Order matters for sequences.
        TypeArray is the general array of types for MULTIPLE options - so remove the weird Type->opt we have for 'print_native'

    parse_type() should really be a switch statement - make a peek_token() that returns the next token (rather than
        peek_one(TokenType) which requires you to guess the next token.

    Change Return AST node and TypeFun so that returns take in a list of expressions, and TypeFun->ret a list of types

    Returns compile each expression in the correct order in the parser - make them compile each expression in the compiler

    If a function call with more than one return is a statement, need to pop equal to the number of returns
        - could just let the compiler handle this.  After compiling the inside of each StmtExpr, we normally
        just pop one, but this time look at the returned type - pop again for each return over 1

    Add multiple return options to functions
        need to make return type a TypeList
        need to make Return node 'right' a NodeList
        return types must be enclosed in parens now
        fun :: (a: int) -> (int) {
            -> 23
        }
        fun :: (a: int) -> () {
        }
        fun :: (a: int) -> (int, string) {
            -> 23, "dog"
        }

        Implement syntax and test with single returns for now.
        Then expand to test multiple returns with assignments - see below

    Just swap order of variables for multiassignment/multideclaration:
        three_returns ::() -> (int, int, int) {
            i := 0
            -> i = i + 1, i = i + 1, i = i + 1
        }
        a, b, c, d = 10, three_returns()

        if compile right side if NOT function
            a has expr for right, and assigned to top of stack
        compile right side to get a function with three returns
            grab b, c and d and reverse
            d has three_returns() for right and is assigned to top of stack after compiling call on function
            c has NULL for right, and assigned to top of stack
            b has NULL for right, and assigned to top of stack

    Get REPL working - this is the key difference between Cebra and other compiled languages like Go

    'with' statement?   Creates a shadow variable with casted type in new scope, but only does so if cast is valid (not nil)
        //this cuts out 1 indent, and 3 lines compared to using 'when/is' statements
        with expr as PrimaryExpr {
            -> expr.token.literal as float
        }

        with expr as BinaryExpr {
            left := evaluate_expr(expr.left)
            right := evaluate_expr(expr.right)
            when expr.token.literal {
                is "+" { -> left + right }
                is "-" { -> left - right }
                is "*" { -> left * right }
                is "/" { -> left / right }
            }
        }

    private keywords?  I want to be able to encapsulate data/functions (mainly for modules)
        //private enums, structs and functions can't be accessed/instantiated, but if
        a function returns it, the user can still use it.

        //the star means add_two and Dog are hidden outside the module
        //Calling the function/struct is done without the * as the * is
        //just to mark it as private and not part of the struct name
        add_two* :: (a: int, b: int) -> (int) {
        }
        Dog* :: struct {
            name* := "Dog" //name is a private field only accessible by parameter marked with*
            class := "Mammal"
        }
        //d's private fields can be accessed
        mutate_dog* :: (d: Dog*, a: int) -> () {
            d.name = "Bubbles" //okay
            d.friend.name = "Mittens" //invalid since only Dog "d" is mutable
        }
        invalid_fun :: (d: Dog) -> () {
            d.name = "Bubbles" //setting is invalid
            str: string = d.name //this is okay
            print(d.name) //reading is still okay
            friend := d.friend //okay
            friend.name = "Bubbles" //invalid
        }

    'break' and 'continue' for loops

    Rewrite Lexer - it's very messy and error prone
        consider writing simple c program that reads in and tokenizes text
        then the program can count tokens to make sure it all adds up
            this would help us know if any changes to the lexer are breaking shit

    Write tests for multi-variable assignment

    Write code for multi-variable returns

    Write code for using multi-variable returns as argument into multi-parameter function
        fun_ret_two :: () -> (int, int) {
        }
        fun_two_params :: (a: int, b: int) -> {
        }
        fun_two_params(fun_ret_two())

    //this is super messy, but paren grouping is necessary to avoid ambiguous return/function relationships
    //a single return is NOT wrapped in parens
        fun :: () -> int {}
        fun :: () -> (int, string) {}
        fun :: () -> (()-> (int, int), ()-> int) {

        }

    Get it parsing
    Get it compiling
    Get it running

    For function types, no take in a TypeArray for returns too
    ret_types during compilation now also need to return TypeArrays
    while parsing, need to redo make_decl_fun to include multiple returns
        and when parsing return statements do the same
    May need to include more info for ObjFun too (right now we have arity, but
        may require return count too)
    
    Need multiple returns for easy file reading
        str, result := read(f) //where read returns a string and boolean where boolean is false if failed

    Reading/Writing to files.  How does python do this?  (or look at other languages)
        consider adding in \n for print() for more flexible ways to output data.

        Maybe generalize reading/writing?
       
        f: file = open("test.txt") //will automatically close with GC?  If so, need to make a runtime representation (ObjFile)
        src := read(f)

        a := read(stdin)
        b := read(file) //read entire file until end
        c := readln(file) //read one line up to, and including, \n
        write("Hello world", stdout)
        write("Hello world", f)

    'import' keyword and importing modules (do this once I have enough native functions to require it)
        how does python, ruby and others do this?
        what is a module?  Structs, Enums and Functions?  
        how should namespaces work (if we decide to use them)
        should native functions be imported?  Or are they always included?

        import "Parser.cbr"
        import "Lexer.cbr"
        import "Evaluator.cbr"

        src := "12 - 23 / 4"
        tokens := scan_source(src)
        ast := parser_tokens(tokens)
        print(evaluate_ast(ast))

    Sockets for TCP and UDP connections - we just want a high level wrapper over the same
        functionality.  Allow the user to create sockets and send bytes (or strings, floats, ints)
    
    Strings are interned.  Since interned strings are only used to removed repeated strings, they shouldn't be marked as a root.  Then
        after all references are traced but before sweeping, we should delete interned string pointers from 
        the hash table that are not marked.  Will need to implement delete entries in a table for this.

    Wrap push(vm, value) in a macro that returns /adds error if above stack limit
        how about when push_root() is over stack limit???

    Allowing struct instantiation in fields, BUT check if there are circular instantiations and show error
        if so.

    Write script to build using both Clang and MSVC, and then run correctness.cbr and interpreter.cbr
    for both executables all in one go.

    Update website for Cebra with new syntax/sections.
        How to download/build src is the most important
            include which compilers + versions tested on and cmake versions
        Don't worry about syntax highlighting for now - can add prism.js later (or other)

    Read:
        The Slightly Disgruntled Scientist tutorial on debugguers - Valgrind and GBD: Tame the Wild C
            https://heeris.id.au/2016/valgrind-gdb/
            
            Example 1: Uninitialized variabls
                Valgrind runs program on synthetic processer. GDB is debugger with breakpoints, single stepping, etc
                run program in Valgrind with any arguments using --vgdb-error=0 flag to allow using GDB
                    use command output by valgrind to run GDB with the currently running program
                can then step through program using GDB, and also send commands to valgrind using 'monitor'
                consider making a 'wat' command to combine address, size, + valgrind command get_vbits into one command
            Chapter 2: Memory leaks

    Test compiling on Windows FOR Linux, and on Linux FOR Windows to see how that works.

    Error messages in compiler are all messed up in compiler.c.  In NODE_FUN, when returning after error sometimes
        the errors in func_comp aren't copied over to the enclosing compiler before func_comp is freed.
        ALSO, on errors func_comp is NOT freed, so the compiler chain isn't reset back to the enclosing compiler
        losing error messages...

    Setting globals in compiler/parser is using the same code 4 times (for enum/struct/fun declaration in
        parser and in define_native() in compiler).  Combine into a single function in compiler called
        add_global(struct Table* globals, struct ObjString*, struct Type* type) and do any checks in there
            will need to make parser/compiler errors compatible if we want to use the same function for both

    Real Problem: Errors didn't stop compilation, which triggered more errors and breaking everything.
        right now we are returning immediately if there is a compilation error of
        one of the nodes.  This cuts things short but at least it works.  Need to figure out a way
        to handle errors - when an error occurs and compile_node returns, any pushed roots or new
        compilers, etc don't get freed, causing the compiler to go into an invalid state.  This then
        triggers problems with GC, etc.

    Continue writing basic interpreter - add any errors below and fix them afterwards
        big problem: we need to access parse_expression() in parse_primary(), but
        the declaration needs to come after....

        will need to do two passes to solve this problem: first pass resolves all :: notation - 
            struct, enum, function declarations. 

            The first pass could shove all that into a global table - then we can access them
            as needed during the second pass when all other code is compiled

    need to make runtime errors leave stack/OpPtr in valid state so that
        more errors can be found during runtime (currently only done for OP_GET_PROP and OP_SET_PROP)
        Add lines to runtime errors... could we emit line numbers along with Ops?
        maybe add compilation errors before doing the runtime ones

    Set memory limit by using system call setrlimit() so that I can put in guards for when memory
        runs out.

    Make function to convert char to ASCII, or allow char (and string?) comparisons using <, <=, >, >=

    Can value_arrary.h/c be merged into value.h/c?

    struct Error (in parser.h) is a general error, and can be used for both the compiler and vm
        get rid of ComilerError and RuntimeError

    'consume' in parser is too general and doesn't allow specific error messages - replacing it with match() + ADD_ERROR will be better
        but it's a lot more verbose

    Need to deal with c-errors too (snprintf, reading from file, etc)
    
    put in 'if' into correctness.cbr to turn on/off tests - this will make it easier to
        pinpoint failing tests/crashing tests
        this doesn't work!!! Need a preprocesser to remove/add/replace code

    type() function that returns 'int', 'string', 'bool', 'float', 'Dog', '(int) -> string' in string format

    change name of TOKEN_STRING_TYPE to TOKEN_STRING_IDENTIFIER so that it can
        be used for both type AND casting to strings

    write code to catch compiler errors: pretty much type checking
        compiling error - if the condition evaulates to non-boolean take care of
            any memory

    'Variable must be assigned to a valid expression' in parser should tell user the variable identifier
        need a way for errors to print token too

    Write code to catch runtime errors: what runtime checks do we do?

    Write code to break maximum parameter/argument, upvalues, and constants limits

    Compile to webassembly and run in browser
        test with simple 'hello world' program first
        test with program that reads in text from text box (our script)
            and returns info about that text
        integrate final code

    Update documentation to include new syntax + List/Map
        and include small box to write /run test scripts

    Write broken code and make sure ALL parsing, compilation, and runtime
        errors are caught.  Make 3 new files: parsing.cbr, compiling.cbr, 
        runtime.cbr with bad code.  Make sure that all mistakes sychronize
        and run to the very end, emitting errors WITHOUT crashing.

    Add string manipulation
        access char by index using [idx]
        property size
        slicing by index [0, 2]

    find python native function list (for early python versions)
        and add those functions
        copy() for instances/lists/maps
        casting to string/int/float

    How about letting declarations leave NIL on the stack, and then 
    popping them off by wrapping them in expr_stmt?  This would
    get rid of the weird NIL checking in OP_POP.

        had bug before where setting a variable to nil and 
        return nil as the type (which didn't get popped)
        changed code so that variable signature was returned

    Need to add parse error if quote is not closed (rather than quietly failing)
        and program crashing

    Need to make parser and compiler errors NOT fail silently and instead
        give user a useful message. Will require more careful handling of
        parse/compiler/runtime errors - including syncing so that multiple
        errors can be shown

    Implement deleting from hash table - need to use tombstones

    Intern strings - create a "strings" table in vm

    Write benchmarking code to use with chrome://tracing to find hotspots

    Why are if /else so much slower than just if (think of the fibonacci example)


StatementList should be DeclList - all programs are a list of declarations
  decl - classDecl | funDecl | varDecl | stmt
      leave no effect on the stack
  stmt - exprStmt | forStmt | ifStmt | printStmt | returnStmt | whileStmt | block
      exprStmt are expressions where the result is discarded (pop the stack)
  expr - Literal | Unary | Binary | SetVar | GetVar
      push one value on the stack


