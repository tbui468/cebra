DOCUMENTATION:
    Look at how Nystrom design docs for Wren
    The embedded compiler/vm in browser is neat
        look at using emscripten to compiler to webassembly

ADDING FEATURES:
    Add correctness tests for new features
    Check that ALL memory is freed if GC is called at end of main()
    Add more native functions - add way to import native functions
    TODO: need a way to test type checking

IMPLEMENTATION:

    Implement structs in Lists

    Write tests for structs in Lists

    Split call_dot into call and dot, just make sure that both options are called
        when doing recursive descent

    should be able to skip checking for TOKEN_EQUAL in call_dot() and just
        check in assignment() - similar to how we dealt with indices with []

    Implement a stack in cebra using List/structs/functions to test List
        create a new file called stack.cbr to save this (can reuse later)

    Implement 'in' keyword to check if value is in list
        should return a boolean

    Implement for each loop
        for i: int in list {
            print(i)
        }

    Add support for maps 
    how to check if key is in map?  Use 'in' keyword:
    this should be used on a list.  Use keys/values/pairs to get a list
    how about structs?  
    if { "dog, 4 } in m.pairs {
        print
    }
    if "dog" in m.keys {
        print(m["dog"])
    }
        key: string
        value: any type
        m: Map<int> = Map<int>()
        m["dog"] = 4
        print(m["dog"]) //prints 4
        print(m["cat"]) //prints ???? need a way to check if key exists
        m.keys //returns a list of strings showing keys
        m.values //returns a list of <type> showing values

    struct inheritance - this will guarentee that Dog is 'ducked'
    as an animal.
        Animal: struct = struct {
            species: string = "Mammal"
        }
        Dog: struct < Animal = struct < Animal {
            name: string = "Bubbles"
        }

    for n: string in list {
        
    }

    Allow shorthand for declaration types:
        a := 1
        b := "dogg"
        c := () -> int {
            -> 3
        }
        Dog := class {
            name := "Mittens"
        }

    When compile_node() is called, should check if return value is NULL
        make all errors return NULL, rather than a signature of type NIL
        NIL type signatures are valid, whereas NULL will signal an error

    find python native function list (for early python versions)
        and add those functions

    Allow struct instantiation to have arguments that set fields
        by order of declaration.  Use must include all arguments, but
        may leave them empty if the default value is desired

        Dog: struct = struct {
            name: string = "Mittens"
            age: int = 3
            length: float = 12.3
        }

        Dog("Bubbles", 23, 1.32)
        Dog(, 23, 1.32)
        Dog(,,) is the same as Dog()

    property names are being added as constants for both OP_GET_PROP
    and OP_SET_PROP, but they aren't really constants.  What other
    way could this be done more clearly.  Interning!!!

    Does NODE_DECl_VAR only for primitive types, or is it for functions/classes too?
        add ability to assign variables to classes, function, instances

        How about assigning functions to other functions?
            I don't think we support this right now:
            my_fun: () -> = other_fun

    Clear up the warnings (especially with switch statements)

    String Interning

    When a function returns, it closes any upvalues, but we don't
        see the call to OP_CLOSE_UPVALUE - need to add more instructions to
        disassemble chunk OR somehow make returning from a function call
        OP_CLOSE_UPVALUE for clarity.  Is there any situation where
        OP_CLOSE_UPVALUE actually gets called (rather than OP_RETURN 
        just doing all the work?)

    in compiler, CALL and CASCADE CALL share a lot of code - pull that into a function

    Native functions - start with clock() for measuring time
        should have an OP_CALL_NATIVE code

    Having to call free_sig on almost all signatures in compile_node is a bit much
      and super prone to errors.  How about putting all Sig* into a list upon
      creation, and then just free that list when the compilation process is over?
        this is similar to how we deal with freeing Objects with the GC

    Implement deleting from hash table - need to use tombstones

    Intern strings - create a "strings" table in vm

    Test Edge cases by writing toy programs - save these programs as correctness tests

    Stress test by writing script to load nyc_subway data - compare runtime to python pandas

    Write benchmarking code to use with chrome://tracing to find hotspots

    Why are if /else so much slower than just if (think of the fibonacci example


StatementList should be DeclList - all programs are a list of declarations
  decl - classDecl | funDecl | varDecl | stmt
      leave no effect on the stack
  stmt - exprStmt | forStmt | ifStmt | printStmt | returnStmt | whileStmt | block
      exprStmt are expressions where the result is discarded (pop the stack)
  expr - Literal | Unary | Binary | SetVar | GetVar
      push one value on the stack


