cmake --build . --config Release cl /O2 ...

Syntax highlighter:
    Push update to the marketplace - fixed typo with function colors not showing

Documentation:

    Make a smaler gif for main page - this one is too big and takes too long to load

    Fill in some basic info for topics on main page

    FInishing formating docs with right side 'aside' boxes

    Look at GifTuna website for simple but effective layout

    Include language specification, eg:
        VarDecl     = "var" ( VarSpec | "(" { VarSpec ";" } ")" ) .
        VarSpec     = IdentifierList ( Type [ "=" ExpressionList ] | "=" ExpressionList ) 

    Clean up colors to make it more simple and clean.

    Update sections titles to match current status

    Update section on how to download/build from source and VSCode syntax highlighter

    Consider looking at Nystrom's Wren to see how he put the interpreter in the browser

    Maybe look into posting it on handmade network/reddit...
        
    Look at Odin-lang for reference for docs
        could just have sample code user can look at rather than an actual interactive panel

Stack overflow
    big stack allocations:
        NODE_WHEN  256 ints
        NODE_SEQUENCE 256 ints
        OP_RETURN 256 Values
        Parser - errors
        Compiler - locals, upvalues, errors
        VM - stack, callframes, errors

Implementation:
    need to handle directory paths with imports.  Currently it looks in cebra.exe directory for imports

    ERROR() in parser automatically returns, which could be bad for allocated memory or other state that
        needs to be cleared.  Create an add_error() function or a macro that does NOT return, and then
        manually return if necessary
           
    Errors could be moved to heap for more stack space - we aren't accessing them much in runnable code anyway. 

    Why does the script compiler keep a list of ALL AST nodes again?  It's passed into the parser since the parser
        resolves identifiers now, and I just wanted to resolve remaining identifiers in the same place.  
        It's the compiler's job to track ALL AST nodes so they can be freed.  
        This is a some coupling between the
        parser and compiler - can we do without it?

    File system interaction
        To simplify the file system access, could store the path as a string in ObjFile, along
        with the read/write mode, eg char 'r', 'w', 'a', etc
        when a user tries to swap between read and write, just close and reopen the file.  This
        also allows user to append a line and then read a line.  Although maybe tell the user
        that swapping between reading and writing can be slow.

        how about an eof(file) function that returns a bool?  But then we would have to be 
        able to peek head since we want to do this:
        
            f := open("test.txt")
            while !eof(f) {
                print(read_line(f))
            }

        This is a lot nicer than worrying about having to open a file in modes.  read_line
        state can also be saved, so that the user can append, then continue reading from 
        the place before.  But, if they use 'write', the read_line position is reset to
        the beginning again.  Will need to figure out how to do the eof() function - this
        might be tricky if we keep appending at the same time as checking.

            f := open("test.txt")
            write(f, "This is a first line")
            append(f, "This is a second line")

            read_all(f)

            while !eof(f) {
                print(read_line(f))
            }
            

            rewind(f)
            read_line(f)

    parser.first_pass_nl should be renamed to parser.static_nodes, and then script_nl to dynamic_nl

    Get website main page up and working

    compile time constants (must be strings, ints, bools, or floats).  Cannot be modified (but client if free to copy and modify copy)
        PI :: 3.14
        MAX_SIZE :: 64

    Allow sequences in struct fields... this may require changing some things since right now sequence declarations
        are immediatly added as locals.  Struct fields need to be pushed onto the stack along with the prop
        name to store in struct definition

        could generalize Sequences further: a sequence is kind of like a higher level data type that can
        be type check as usual.  This would allow us to make function arguments be a Sequence so that
        a return from a function (itself a sequence) can be passed directly into a different function.
        If there are embedded sequences, they need to be unwrapped to form a single depth Sequence

    Integrate Sequences into function arguments to allow this:
        takes_three(returns_two(), third_arg())

    Simplify code and make it fast - this is supposed to be a selling point
        swap struct and enum tables for value arrays
        structs and enums indices can be determined at compile time and index emitted after set/get prop
        at runtime we just need to increment the pointer instead of a table lookup

    'with' statement?   Creates a shadow variable with casted type in new scope, but only does so if cast is valid (not nil)
        //this cuts out 1 indent, and 3 lines compared to using 'when/is' statements
        with expr as PrimaryExpr
            -> expr.token.literal as float

        with expr as BinaryExpr {
            left := evaluate_expr(expr.left)
            right := evaluate_expr(expr.right)
            when expr.token.literal {
                is "+" -> left + right
                is "-" -> left - right
                is "*" -> left * right
                is "/" -> left / right
            }
        }

    private keywords?  I want to be able to encapsulate data/functions (mainly for modules)
        //private enums, structs and functions can't be accessed/instantiated, but if
        a function returns it, the user can still use it.

        //the star means add_two and Dog are hidden outside the module
        //Calling the function/struct is done without the * as the * is
        //just to mark it as private and not part of the struct name
        add_two* :: (a: int, b: int) -> (int) {
        }
        Dog* :: struct {
            name* := "Dog" //name is a private field only accessible by parameter marked with*
            class := "Mammal"
        }
        //d's private fields can be accessed
        mutate_dog* :: (d: Dog*, a: int) -> () {
            d.name = "Bubbles" //okay
            d.friend.name = "Mittens" //invalid since only Dog "d" is mutable
        }
        invalid_fun :: (d: Dog) -> () {
            d.name = "Bubbles" //setting is invalid
            str: string = d.name //this is okay
            print(d.name) //reading is still okay
            friend := d.friend //okay
            friend.name = "Bubbles" //invalid
        }

    'break' and 'continue' for loops

    Rewrite Lexer - it's very messy and error prone
        consider writing simple c program that reads in and tokenizes text
        then the program can count tokens to make sure it all adds up
            this would help us know if any changes to the lexer are breaking shit

    Write tests for multi-variable assignment

    Write code for multi-variable returns

    Write code for using multi-variable returns as argument into multi-parameter function
        fun_ret_two :: () -> (int, int) {
        }
        fun_two_params :: (a: int, b: int) -> {
        }
        fun_two_params(fun_ret_two())

    //this is super messy, but paren grouping is necessary to avoid ambiguous return/function relationships
    //a single return is NOT wrapped in parens
        fun :: () -> int {}
        fun :: () -> (int, string) {}
        fun :: () -> (()-> (int, int), ()-> int) {

        }

    Get it parsing
    Get it compiling
    Get it running

    For function types, no take in a TypeArray for returns too
    ret_types during compilation now also need to return TypeArrays
    while parsing, need to redo make_decl_fun to include multiple returns
        and when parsing return statements do the same
    May need to include more info for ObjFun too (right now we have arity, but
        may require return count too)
    
    Need multiple returns for easy file reading
        str, result := read(f) //where read returns a string and boolean where boolean is false if failed

    Reading/Writing to files.  How does python do this?  (or look at other languages)
        consider adding in \n for print() for more flexible ways to output data.

        Maybe generalize reading/writing?
       
        f: file = open("test.txt") //will automatically close with GC?  If so, need to make a runtime representation (ObjFile)
        src := read(f)

        a := read(stdin)
        b := read(file) //read entire file until end
        c := readln(file) //read one line up to, and including, \n
        write("Hello world", stdout)
        write("Hello world", f)

    'import' keyword and importing modules (do this once I have enough native functions to require it)
        how does python, ruby and others do this?
        what is a module?  Structs, Enums and Functions?  
        how should namespaces work (if we decide to use them)
        should native functions be imported?  Or are they always included?

        import "Parser.cbr"
        import "Lexer.cbr"
        import "Evaluator.cbr"

        src := "12 - 23 / 4"
        tokens := scan_source(src)
        ast := parser_tokens(tokens)
        print(evaluate_ast(ast))

    Sockets for TCP and UDP connections - we just want a high level wrapper over the same
        functionality.  Allow the user to create sockets and send bytes (or strings, floats, ints)
    
    Strings are interned.  Since interned strings are only used to removed repeated strings, they shouldn't be marked as a root.  Then
        after all references are traced but before sweeping, we should delete interned string pointers from 
        the hash table that are not marked.  Will need to implement delete entries in a table for this.

    Wrap push(vm, value) in a macro that returns /adds error if above stack limit
        how about when push_root() is over stack limit???

    Allowing struct instantiation in fields, BUT check if there are circular instantiations and show error
        if so.

    Write script to build using both Clang and MSVC, and then run correctness.cbr and interpreter.cbr
    for both executables all in one go.

    Update website for Cebra with new syntax/sections.
        How to download/build src is the most important
            include which compilers + versions tested on and cmake versions
        Don't worry about syntax highlighting for now - can add prism.js later (or other)

    Read:
        The Slightly Disgruntled Scientist tutorial on debugguers - Valgrind and GBD: Tame the Wild C
            https://heeris.id.au/2016/valgrind-gdb/
            
            Example 1: Uninitialized variabls
                Valgrind runs program on synthetic processer. GDB is debugger with breakpoints, single stepping, etc
                run program in Valgrind with any arguments using --vgdb-error=0 flag to allow using GDB
                    use command output by valgrind to run GDB with the currently running program
                can then step through program using GDB, and also send commands to valgrind using 'monitor'
                consider making a 'wat' command to combine address, size, + valgrind command get_vbits into one command
            Chapter 2: Memory leaks

    Test compiling on Windows FOR Linux, and on Linux FOR Windows to see how that works.

    Error messages in compiler are all messed up in compiler.c.  In NODE_FUN, when returning after error sometimes
        the errors in func_comp aren't copied over to the enclosing compiler before func_comp is freed.
        ALSO, on errors func_comp is NOT freed, so the compiler chain isn't reset back to the enclosing compiler
        losing error messages...

    Setting globals in compiler/parser is using the same code 4 times (for enum/struct/fun declaration in
        parser and in define_native() in compiler).  Combine into a single function in compiler called
        add_global(struct Table* globals, struct ObjString*, struct Type* type) and do any checks in there
            will need to make parser/compiler errors compatible if we want to use the same function for both

    Real Problem: Errors didn't stop compilation, which triggered more errors and breaking everything.
        right now we are returning immediately if there is a compilation error of
        one of the nodes.  This cuts things short but at least it works.  Need to figure out a way
        to handle errors - when an error occurs and compile_node returns, any pushed roots or new
        compilers, etc don't get freed, causing the compiler to go into an invalid state.  This then
        triggers problems with GC, etc.

    Continue writing basic interpreter - add any errors below and fix them afterwards
        big problem: we need to access parse_expression() in parse_primary(), but
        the declaration needs to come after....

        will need to do two passes to solve this problem: first pass resolves all :: notation - 
            struct, enum, function declarations. 

            The first pass could shove all that into a global table - then we can access them
            as needed during the second pass when all other code is compiled

    need to make runtime errors leave stack/OpPtr in valid state so that
        more errors can be found during runtime (currently only done for OP_GET_PROP and OP_SET_PROP)
        Add lines to runtime errors... could we emit line numbers along with Ops?
        maybe add compilation errors before doing the runtime ones

    Set memory limit by using system call setrlimit() so that I can put in guards for when memory
        runs out.

    Make function to convert char to ASCII, or allow char (and string?) comparisons using <, <=, >, >=

    Can value_arrary.h/c be merged into value.h/c?

    struct Error (in parser.h) is a general error, and can be used for both the compiler and vm
        get rid of ComilerError and RuntimeError

    'consume' in parser is too general and doesn't allow specific error messages - replacing it with match() + ADD_ERROR will be better
        but it's a lot more verbose

    Need to deal with c-errors too (snprintf, reading from file, etc)
    
    put in 'if' into correctness.cbr to turn on/off tests - this will make it easier to
        pinpoint failing tests/crashing tests
        this doesn't work!!! Need a preprocesser to remove/add/replace code

    type() function that returns 'int', 'string', 'bool', 'float', 'Dog', '(int) -> string' in string format

    change name of TOKEN_STRING_TYPE to TOKEN_STRING_IDENTIFIER so that it can
        be used for both type AND casting to strings

    write code to catch compiler errors: pretty much type checking
        compiling error - if the condition evaulates to non-boolean take care of
            any memory

    'Variable must be assigned to a valid expression' in parser should tell user the variable identifier
        need a way for errors to print token too

    Write code to catch runtime errors: what runtime checks do we do?

    Write code to break maximum parameter/argument, upvalues, and constants limits

    Compile to webassembly and run in browser
        test with simple 'hello world' program first
        test with program that reads in text from text box (our script)
            and returns info about that text
        integrate final code

    Update documentation to include new syntax + List/Map
        and include small box to write /run test scripts

    Write broken code and make sure ALL parsing, compilation, and runtime
        errors are caught.  Make 3 new files: parsing.cbr, compiling.cbr, 
        runtime.cbr with bad code.  Make sure that all mistakes sychronize
        and run to the very end, emitting errors WITHOUT crashing.

    Add string manipulation
        access char by index using [idx]
        property size
        slicing by index [0, 2]

    find python native function list (for early python versions)
        and add those functions
        copy() for instances/lists/maps
        casting to string/int/float

    How about letting declarations leave NIL on the stack, and then 
    popping them off by wrapping them in expr_stmt?  This would
    get rid of the weird NIL checking in OP_POP.

        had bug before where setting a variable to nil and 
        return nil as the type (which didn't get popped)
        changed code so that variable signature was returned

    Need to add parse error if quote is not closed (rather than quietly failing)
        and program crashing

    Need to make parser and compiler errors NOT fail silently and instead
        give user a useful message. Will require more careful handling of
        parse/compiler/runtime errors - including syncing so that multiple
        errors can be shown

    Implement deleting from hash table - need to use tombstones

    Intern strings - create a "strings" table in vm

    Write benchmarking code to use with chrome://tracing to find hotspots

    Why are if /else so much slower than just if (think of the fibonacci example)


StatementList should be DeclList - all programs are a list of declarations
  decl - classDecl | funDecl | varDecl | stmt
      leave no effect on the stack
  stmt - exprStmt | forStmt | ifStmt | printStmt | returnStmt | whileStmt | block
      exprStmt are expressions where the result is discarded (pop the stack)
  expr - Literal | Unary | Binary | SetVar | GetVar
      push one value on the stack


