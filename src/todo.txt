DOCUMENTATION:
    Look at how Nystrom design docs for Wren
    The embedded compiler/vm in browser is neat

IMPLEMENTATION:

    Redo class and instances
        Will want to make an ObjClosure
            I avoided it earlier, but this will make it easier to implement
                classes (for properties and methods, in particular)
            Abstract functionality out of ObjFunction, and refactor to 
                make sure it all works before redoing ObjClass/ObjInstance
        OLD NOTES: 
        Get NODE_CLASS working with new defs table - in call frames
          should just need to use OP_SET/GET_DEF since they all use Values

        OP_INSTANCE in vm.c needs to be completed - look at notes in vm.c OP_INSTANCE
         basic problem: how to go from ObjClass -> Table necessary for instance?

    Clear up the warnings (especially with switch statements)

    When a function returns, it closes any upvalues, but we don't
        see the call to OP_CLOSE_UPVALUE - need to add more instructions to
        disassemble chunk OR somehow make returning from a function call
        OP_CLOSE_UPVALUE for clarity.  Is there any situation where
        OP_CLOSE_UPVALUE actually gets called (rather than OP_RETURN 
        just doing all the work?)

    in compiler, CALL and CASCADE CALL share a lot of code - pull that into a function

    Native functions - start with clock() for measuring time
        should have an OP_CALL_NATIVE code

    Having to call free_sig on almost all signatures in compile_node is a bit much
      and super prone to errors.  How about putting all Sig* into a list upon
      creation, and then just free that list when the compilation process is over?
        this is similar to how we deal with freeing Objects with the GC

    Implement deleting from hash table - need to use tombstones

    Intern strings - create a "strings" table in vm

    Test Edge cases by writing toy programs - save these programs as correctness tests

    Stress test by writing script to load nyc_subway data - compare runtime to python pandas

    Write benchmarking code to use with chrome://tracing to find hotspots

    Why are if /else so much slower than just if (think of the fibonacci example


StatementList should be DeclList - all programs are a list of declarations
  decl - classDecl | funDecl | varDecl | stmt
      leave no effect on the stack
  stmt - exprStmt | forStmt | ifStmt | printStmt | returnStmt | whileStmt | block
      exprStmt are expressions where the result is discarded (pop the stack)
  expr - Literal | Unary | Binary | SetVar | GetVar
      push one value on the stack


