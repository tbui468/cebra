DOCUMENTATION:
    Look at how Nystrom design docs for Wren
    The embedded compiler/vm in browser is neat
        look at using emscripten to compiler to webassembly

ADDING FEATURES:
    Add correctness tests for new features
    Check that ALL memory is freed if GC is called at end of main()
    Add more native functions - add way to import native functions
    TODO: need a way to test type checking

IMPLEMENTATION:

    Can we make NodeList an ast node?  Put it inside the same header/.c

        add free_node() for NodeList
        add print_node() for NodeList

    free_node() should NOT free any subnodes now - leave it to the linked
    list to free all nodes together.

    Nodes should be added to a linked list (similar to Sigs)
    and deleted as a batch.  This will simplify the memory management
    for error handling in parser.

        add nodes linked list to compiler and free them when compiler
        is freed.

    add parsing errors for other declarations

    check other errors in parser not included inside declaration()
        make sure memory is freed
        make format consistent with other changes

    compiling error - if the condition evaulates to non-boolean take care of
        any memory

    Compile to webassembly and run in browser
        test with simple 'hello world' program first
        test with program that reads in text from text box (our script)
            and returns info about that text
        integrate final code

    Whenever a SigIdentifier is used, it should be resolved at
        that time - is there a way to automate this rather
        than checking if type == SIG_IDENTIFIER and resolving
        the signature each time?  It's prone to mistakes.

    Need to work on error handling in parser, compiler, runtime
        we don't want any crashes - bad syntax / logic should
        report an error, synchronize if necessary, and move on 
        if possible

    this code should give error since declaring same variable twice
    but it currently crashes program
        //expecting 'and' between
        if yy() == "hello world" yyi() == "hello world" {

        //Look at List tests, setting same variable to different list templates
        a: List<int> = List<int>(-1)
        a: List<Dog> = List<Dog>(Dog()) //this should report and error

    Update documentation to include new syntax + List/Map
        and include small box to write /run test scripts

    Write broken code and make sure ALL parsing, compilation, and runtime
        errors are caught.  Make 3 new files: parsing.cbr, compiling.cbr, 
        runtime.cbr with bad code.  Make sure that all mistakes sychronize
        and run to the very end, emitting errors WITHOUT crashing.

    have Maps and Lists return nil for invalid values
        make this an option (if argument is nothing)
        get rid of default values
        in vm, fill invalid values with nil
        change tests to match 

    Add string manipulation
        access char by index using [idx]
        property size
        slicing by index [0, 2]

    find python native function list (for early python versions)
        and add those functions
        copy() for instances/lists/maps
        casting to string/int/float

    How about letting declarations leave NIL on the stack, and then 
    popping them off by wrapping them in expr_stmt?  This would
    get rid of the weird NIL checking in OP_POP.

        had bug before where setting a variable to nil and 
        return nil as the type (which didn't get popped)
        changed code so that variable signature was returned

    Implement for each loop
        foreach i: int in list {
            print(i)
        }

        foreach i: string in map.keys {
            print(map[i])
        }

        for i: int in 1..19 {

        }

    copy() to make copies of instances, maps and lists

    Need to add parse error if quote is not closed (rather than quietly failing)
        and program crashing

    Need to make parser and compiler errors NOT fail silently and instead
        give user a useful message. Will require more careful handling of
        parse/compiler/runtime errors - including syncing so that multiple
        errors can be shown

    When compile_node() is called, should check if return value is NULL
        make all errors return NULL, rather than a signature of type NIL
        NIL type signatures are valid, whereas NULL will signal an error

    Allow struct instantiation to have arguments that set fields
        by order of declaration.  Use must include all arguments, but
        may leave them empty if the default value is desired

        Dog: struct = struct {
            name: string = "Mittens"
            age: int = 3
            length: float = 12.3
        }

        Dog("Bubbles", 23, 1.32)
        Dog(, 23, 1.32)
        Dog(,,) is the same as Dog()

    property names are being added as constants for both OP_GET_PROP
    and OP_SET_PROP, but they aren't really constants.  What other
    way could this be done more clearly.  Interning!!!
        this will also make value comparisons of strings faster
        (right now need to compare lengths + memcmp)

    Does NODE_DECl_VAR only for primitive types, or is it for functions/classes too?
        add ability to assign variables to classes, function, instances

        How about assigning functions to other functions?
            I don't think we support this right now:
            my_fun: () -> = other_fun

    Clear up the warnings (especially with switch statements)

    String Interning

    When a function returns, it closes any upvalues, but we don't
        see the call to OP_CLOSE_UPVALUE - need to add more instructions to
        disassemble chunk OR somehow make returning from a function call
        OP_CLOSE_UPVALUE for clarity.  Is there any situation where
        OP_CLOSE_UPVALUE actually gets called (rather than OP_RETURN 
        just doing all the work?)

    in compiler, CALL and CASCADE CALL share a lot of code - pull that into a function

    Native functions - start with clock() for measuring time
        should have an OP_CALL_NATIVE code

    Having to call free_sig on almost all signatures in compile_node is a bit much
      and super prone to errors.  How about putting all Sig* into a list upon
      creation, and then just free that list when the compilation process is over?
        this is similar to how we deal with freeing Objects with the GC

    Implement deleting from hash table - need to use tombstones

    Intern strings - create a "strings" table in vm

    Test Edge cases by writing toy programs - save these programs as correctness tests

    Stress test by writing script to load nyc_subway data - compare runtime to python pandas

    Write benchmarking code to use with chrome://tracing to find hotspots

    Why are if /else so much slower than just if (think of the fibonacci example


StatementList should be DeclList - all programs are a list of declarations
  decl - classDecl | funDecl | varDecl | stmt
      leave no effect on the stack
  stmt - exprStmt | forStmt | ifStmt | printStmt | returnStmt | whileStmt | block
      exprStmt are expressions where the result is discarded (pop the stack)
  expr - Literal | Unary | Binary | SetVar | GetVar
      push one value on the stack


