DOCUMENTATION:
    Deconstruct Wren to see how Nystom got the interpereter running in browser
        recreate website locally to see if the interpreter can run locally
        Analyze the 'try' page and get my own wasm/js compiled from C working

    Look at WebAssembly/test_html.html to see current code
        can load simple.wasm (last commented out block), but it's
        not a function that returns anything 

    Trying other things...

ADDING FEATURES:
    Add correctness tests for new features
    Check that ALL memory is freed if GC is called at end of main()
    Add more native functions - add way to import native functions
    TODO: need a way to test type checking

IMPLEMENTATION:
    Change DeclClass node to DeclStruct
    
    Change OP_CLASS to OP_STRUCT

    Replace three memcmp + length comparisons in same_type() with same_key/same_string in table.c


    String interning!!!
        measure how many ObjStrings we have now for interpreter.cbr and correctness.cbr
        intern strings in vm (don't worry about deleting them now, so don't need to mark_table)
            but will need to deal with hanging pointers later

    Allowing struct instantiation in fields, BUT check if there are circular instantiations and show error
        if so.

    Write script to build using both Clang and MSVC, and then run correctness.cbr and interpreter.cbr
    for both executables all in one go.

    Update website for Cebra with new syntax/sections.
        How to download/build src is the most important
            include which compilers + versions tested on and cmake versions
        Don't worry about syntax highlighting for now - can add prism.js later (or other)

    Read:
        The Slightly Disgruntled Scientist tutorial on debugguers - Valgrind and GBD: Tame the Wild C
            https://heeris.id.au/2016/valgrind-gdb/
            
            Example 1: Uninitialized variabls
                Valgrind runs program on synthetic processer. GDB is debugger with breakpoints, single stepping, etc
                run program in Valgrind with any arguments using --vgdb-error=0 flag to allow using GDB
                    use command output by valgrind to run GDB with the currently running program
                can then step through program using GDB, and also send commands to valgrind using 'monitor'
                consider making a 'wat' command to combine address, size, + valgrind command get_vbits into one command
            Chapter 2: Memory leaks

    Test compiling on Windows FOR Linux, and on Linux FOR Windows to see how that works.

    Error messages in compiler are all messed up in compiler.c.  In NODE_FUN, when returning after error sometimes
        the errors in func_comp aren't copied over to the enclosing compiler before func_comp is freed.
        ALSO, on errors func_comp is NOT freed, so the compiler chain isn't reset back to the enclosing compiler
        losing error messages...

    Test regular vs anonymous functions.  Make sure that failure states give off errors messages
        Add tests by compiling enums/structs/functions/closures in different orders

    Setting globals in compiler/parser is using the same code 4 times (for enum/struct/fun declaration in
        parser and in define_native() in compiler).  Combine into a single function in compiler called
        add_global(struct Table* globals, struct ObjString*, struct Type* type) and do any checks in there
            will need to make parser/compiler errors compatible if we want to use the same function for both

    Real Problem: Errors didn't stop compilation, which triggered more errors and breaking everything.
        right now we are returning immediately if there is a compilation error of
        one of the nodes.  This cuts things short but at least it works.  Need to figure out a way
        to handle errors - when an error occurs and compile_node returns, any pushed roots or new
        compilers, etc don't get freed, causing the compiler to go into an invalid state.  This then
        triggers problems with GC, etc.


    Continue writing basic interpreter - add any errors below and fix them afterwards
        big problem: we need to access parse_expression() in parse_primary(), but
        the declaration needs to come after....

        will need to do two passes to solve this problem: first pass resolves all :: notation - 
            struct, enum, function declarations. 

            The first pass could shove all that into a global table - then we can access them
            as needed during the second pass when all other code is compiled

    need to make runtime errors leave stack/OpPtr in valid state so that
        more errors can be found during runtime (currently only done for OP_GET_PROP and OP_SET_PROP)
        Add lines to runtime errors... could we emit line numbers along with Ops?
        maybe add compilation errors before doing the runtime ones


    Struct constructors - would like to be able to do this to simplify code further:
        p := PrimaryExpr(ASTType.primary, token)
        b := BinaryExpr(ASTType.binary, token, left, right)

        No arguments to use all default values.
        Or leave argument empty to use default, eg:
            c := BinaryExpr(, token,, right) //use default for type and left

    Set memory limit by using system call setrlimit() so that I can put in guards for when memory
        runs out.

    Make function to convert char to ASCII, or allow char (and string?) comparisons using <, <=, >, >=

    Can value_arrary.h/c be merged into value.h/c?

    struct Error (in parser.h) is a general error, and can be used for both the compiler and vm
        get rid of ComilerError and RuntimeError

    'consume' in parser is too general and doesn't allow specific error messages - replacing it with match() + ADD_ERROR will be better
        but it's a lot more verbose

    Need to deal with c-errors too (snprintf, reading from file, etc)
    
    put in 'if' into correctness.cbr to turn on/off tests - this will make it easier to
        pinpoint failing tests/crashing tests
        this doesn't work!!! Need a preprocesser to remove/add/replace code

    type() function that returns 'int', 'string', 'bool', 'float', 'Dog', '(int) -> string' in string format

    change name of TOKEN_STRING_TYPE to TOKEN_STRING_IDENTIFIER so that it can
        be used for both type AND casting to strings

    write code to catch compiler errors: pretty much type checking
        compiling error - if the condition evaulates to non-boolean take care of
            any memory

    'Variable must be assigned to a valid expression' in parser should tell user the variable identifier
        need a way for errors to print token too

    Write code to catch runtime errors: what runtime checks do we do?

    Write code to break maximum parameter/argument, upvalues, and constants limits

    Compile to webassembly and run in browser
        test with simple 'hello world' program first
        test with program that reads in text from text box (our script)
            and returns info about that text
        integrate final code

    Update documentation to include new syntax + List/Map
        and include small box to write /run test scripts

    Write broken code and make sure ALL parsing, compilation, and runtime
        errors are caught.  Make 3 new files: parsing.cbr, compiling.cbr, 
        runtime.cbr with bad code.  Make sure that all mistakes sychronize
        and run to the very end, emitting errors WITHOUT crashing.

    Add string manipulation
        access char by index using [idx]
        property size
        slicing by index [0, 2]

    find python native function list (for early python versions)
        and add those functions
        copy() for instances/lists/maps
        casting to string/int/float

    How about letting declarations leave NIL on the stack, and then 
    popping them off by wrapping them in expr_stmt?  This would
    get rid of the weird NIL checking in OP_POP.

        had bug before where setting a variable to nil and 
        return nil as the type (which didn't get popped)
        changed code so that variable signature was returned

    Need to add parse error if quote is not closed (rather than quietly failing)
        and program crashing

    Need to make parser and compiler errors NOT fail silently and instead
        give user a useful message. Will require more careful handling of
        parse/compiler/runtime errors - including syncing so that multiple
        errors can be shown

    Implement deleting from hash table - need to use tombstones

    Intern strings - create a "strings" table in vm

    Write benchmarking code to use with chrome://tracing to find hotspots

    Why are if /else so much slower than just if (think of the fibonacci example)


StatementList should be DeclList - all programs are a list of declarations
  decl - classDecl | funDecl | varDecl | stmt
      leave no effect on the stack
  stmt - exprStmt | forStmt | ifStmt | printStmt | returnStmt | whileStmt | block
      exprStmt are expressions where the result is discarded (pop the stack)
  expr - Literal | Unary | Binary | SetVar | GetVar
      push one value on the stack


