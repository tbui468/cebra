DOCUMENTATION:
    Deconstruct Wren to see how Nystom got the interpereter running in browser
        recreate website locally to see if the interpreter can run locally
        Analyze the 'try' page and get my own wasm/js compiled from C working

    Look at WebAssembly/test_html.html to see current code
        can load simple.wasm (last commented out block), but it's
        not a function that returns anything 

    Trying other things...

ADDING FEATURES:
    Add correctness tests for new features
    Check that ALL memory is freed if GC is called at end of main()
    Add more native functions - add way to import native functions
    TODO: need a way to test type checking

IMPLEMENTATION:

f :: () -> Token {
    print("f")
    -> Token.one
}

top :: () -> Dog {
    print("top")
//    bottom(Dog())
    -> Dog()
}

bottom :: (d: Dog) -> Token {
    print("bottom")
    //middle() is invalid code (since regular functions can't capture state)
    -> Token.one
}

a := 23

middle := () -> {
    a = a + 1
}


Dog :: struct {
    name := "Mittens"
}

Token :: enum {
    one
    two
    three
}

    Need to add native functions to globals instead of locals - making them
        locals means that the function is an upvalue, which causes the function/closure
        separation to break.

    setting globals in compiler/parser is using the same code 4 times (for enum/struct/fun declaration in
        parser and in define_native() in compiler).  Combine into a single function in compiler called
        add_global(struct Table* globals, struct ObjString*, struct Type* type) and do any checks in there
            will need to make parser/compiler errors compatible if we want to use the same function for both

    Real Problem: Errors didn't stop compilation, which triggered more errors and breaking everything.
        right now we are returning immediately if there is a compilation error of
        one of the nodes.  This cuts things short but at least it works.  Need to figure out a way
        to handle errors - when an error occurs and compile_node returns, any pushed roots or new
        compilers, etc don't get freed, causing the compiler to go into an invalid state.  This then
        triggers problems with GC, etc.

    Problem with GC again...
        why is mark_compiler_roots looping?  current->next is never NULL....
        Is it because

    Need to split 'regular' functions from anonymous functions (closures).  
        resolve any identifiers in parameters/return
        need to fix compiler NODE_FUN - function type?, OP_ADD_GLOBAL
        order of compilation shouldn't matter since we only need any called functions in body
            to be resolved at runtime
        during compilation, need to split into two parts (with a lot of shared code):
            for 'regular' functions, add to globals and check for invalid access of state
            for anonymous functions, add to locals

    fun :: () -> {
        //cannot capture state, BUT can be declared anywhere
    }

    clo := () -> {
        //can capture state, but must be declared before usage
        //clo is a closure that can be passed into/returned from functions
    }

    ano := () -> int {
        //anonymous function can be declared and called immediately.  'ano' is assigned to int '3'
        -> 3
    }()

    Change functions to global:
        Problem with all functions being able to capture state (closures)
            Closure need to be declared before usage so that the current state can be captured - this prevents us from 
            declaring functions anywhere.
        Could what Golang does: only anonymous functions can capture - they are declared and invoked at the same time so
            that prevents the above runtime error!  I like this technique - it's very elegant.

            One other option is to somehow figure out if a function is capturing state - if so, don't compile it before hand
                but this could get tricky.  Could create different syntax for closure declaration - but is that too confusing?

                fun :: () -> {}  //compiled before and can be used out of order, but cannot capture state
                    trying to do so should result in compiler error
                () -> {} //anonymous functions can capture state (anonymous function = closure)
                fun := () -> {} //To reuse a closure, assign an anonymous function to a variable (functions are first class in cebra)
                    and resuse as needed

    Move native functions from stack to globals table in vm.

    Add when (switch) statements
    Will 'is' conflict with current usage?  Is it currently used?
        when a {
            is 7:
                //do this - breaks are automatic
            is 12:
                //do this
            else:
                //do this
        }

    Continue writing basic interpreter - add any errors below and fix them afterwards
        big problem: we need to access parse_expression() in parse_primary(), but
        the declaration needs to come after....

        will need to do two passes to solve this problem: first pass resolves all :: notation - 
            struct, enum, function declarations. 

            The first pass could shove all that into a global table - then we can access them
            as needed during the second pass when all other code is compiled

    need to make runtime errors leave stack/OpPtr in valid state so that
        more errors can be found during runtime (currently only done for OP_GET_PROP and OP_SET_PROP)
        Add lines to runtime errors... could we emit line numbers along with Ops?
        maybe add compilation errors before doing the runtime ones

    parse_type() should be a switch, and not a bunch of 'if' statements
        change name to parse_type, and make PARSE_TYPE macro

        make a peek(0) return the next token

        primary() in parser should also use a switch

    see if Token var_name propagated through the descent parser is being used
        Recall that how variables/structs/functions/enums are declared was changed

    This should create an error: 
    z := Zebra //wrong syntax for instantiating struct (missing '()')

    This should create error since nothing is returned
        bottom :: (d: Dog) -> Token {
            print("bottom")
        }

    This should create error:
        Animal :: struct {
            class: string = "Mammal"
        }

        Bird :: struct < Animal {
            class: string = "Avian"
            name: string = "Flappy"
        }

        a: Animal = Bird() //this should give error since Bird() returns Bird type, not Animal
        //user must explicitly cast to Animal type

    This crashes since parse_factor() is not defined
        parse_term := () -> Expr {
            left := parse_factor()

            while match(TokenType.plus) or match(TokenType.minus) {
                left = make_binary_expr(previous_token, left, parse_primary())
            }

            -> left
        }

    This crashes since 'animal' is not defined (typo since we called it 'a')
        a := dog as Animal
        d := animal as Dog

    This crashes since fp was not declared
        fp = -2.3 as string
        print(fp[2])

    This crashes - enum name is misspelled (should be ASTType.primary)
        PrimaryExpr := struct < Expr {
            type := ASype.primary
            token: Token = nil
        }

    This breaks compiler but doesn't show error:
        src := "212 + 42"

        TokenType := enum {
            number
            plus
            minus
        }

        Token := struct {
            TokenType := TokenType.number //Var identifier is expected, but using enum identifer... (but what if user tries to declara new enum???)
            identifier := ""
        }

    This breaks compiler without showing error:
        Token token = Token() //may be related to error above too

    This breaks compiler since 'char_remaing' is not defined, but shows no error
        if char_remaing {

        }

    Struct constructors - would like to be able to do this to simplify code further:
        p := PrimaryExpr(ASTType.primary, token)
        b := BinaryExpr(ASTType.binary, token, left, right)

        No arguments to use all default values.
        Or leave argument empty to use default, eg:
            c := BinaryExpr(, token,, right) //use default for type and left

    Set memory limit by using system call setrlimit() so that I can put in guards for when memory
        runs out.

    Make function to convert char to ASCII, or allow char (and string?) comparisons using <, <=, >, >=

    Can value_arrary.h/c be merged into value.h/c?

    struct Error (in parser.h) is a general error, and can be used for both the compiler and vm
        get rid of ComilerError and RuntimeError

    'consume' in parser is too general and doesn't allow specific error messages - replacing it with match() + ADD_ERROR will be better
        but it's a lot more verbose

    Change SigDecl to SigInferred for clarity
        since SigDecl is only used with :=

    Need to deal with c-errors too (snprintf, reading from file, etc)
    
    put in 'if' into correctness.cbr to turn on/off tests - this will make it easier to
        pinpoint failing tests/crashing tests
        this doesn't work!!! Need a preprocesser to remove/add/replace code

    int casting (string, float)
        if string cannot be converted, ??

    float casting (string, int)
        if string cannot be converted, ??

    type() function that returns 'int', 'string', 'bool', 'float', 'Dog', '(int) -> string' in string format

    change name of TOKEN_STRING_TYPE to TOKEN_STRING_IDENTIFIER so that it can
        be used for both type AND casting to strings

    Write a tree-walk interpreter in cebra to flaws in code
        print(nil) should this work?

    write code to catch compiler errors: pretty much type checking
        compiling error - if the condition evaulates to non-boolean take care of
            any memory

    'Variable must be assigned to a valid expression' in parser should tell user the variable identifier
        need a way for errors to print token too

    Write code to catch runtime errors: what runtime checks do we do?

    Write code to break maximum parameter/argument, upvalues, and constants limits

    Compile to webassembly and run in browser
        test with simple 'hello world' program first
        test with program that reads in text from text box (our script)
            and returns info about that text
        integrate final code

    Whenever a SigIdentifier is used, it should be resolved at
        that time - is there a way to automate this rather
        than checking if type == SIG_IDENTIFIER and resolving
        the signature each time?  It's prone to mistakes.

        whenever an ast node sig is used, pass it through an identifier filter function
            to automatically resolve thes signature if it's SIG_IDENTIFIER

    this code should give error since declaring same variable twice
    but it currently crashes program
        //expecting 'and' between
        if yy() == "hello world" yyi() == "hello world" {

        //Look at List tests, setting same variable to different list templates
        a: List<int> = List<int>(-1)
        a: List<Dog> = List<Dog>(Dog()) //this should report and error

    Update documentation to include new syntax + List/Map
        and include small box to write /run test scripts

    Write broken code and make sure ALL parsing, compilation, and runtime
        errors are caught.  Make 3 new files: parsing.cbr, compiling.cbr, 
        runtime.cbr with bad code.  Make sure that all mistakes sychronize
        and run to the very end, emitting errors WITHOUT crashing.

    have Maps and Lists return nil for invalid values
        make this an option (if argument is nothing)
        get rid of default values
        in vm, fill invalid values with nil
        change tests to match 

    Add string manipulation
        access char by index using [idx]
        property size
        slicing by index [0, 2]

    find python native function list (for early python versions)
        and add those functions
        copy() for instances/lists/maps
        casting to string/int/float

    How about letting declarations leave NIL on the stack, and then 
    popping them off by wrapping them in expr_stmt?  This would
    get rid of the weird NIL checking in OP_POP.

        had bug before where setting a variable to nil and 
        return nil as the type (which didn't get popped)
        changed code so that variable signature was returned

    Implement for each loop
        foreach i: int in list {
            print(i)
        }

        foreach i: string in map.keys {
            print(map[i])
        }

        for i: int in 1..19 {

        }

    copy() to make copies of instances, maps and lists

    Need to add parse error if quote is not closed (rather than quietly failing)
        and program crashing

    Need to make parser and compiler errors NOT fail silently and instead
        give user a useful message. Will require more careful handling of
        parse/compiler/runtime errors - including syncing so that multiple
        errors can be shown

    When compile_node() is called, should check if return value is NULL
        make all errors return NULL, rather than a signature of type NIL
        NIL type signatures are valid, whereas NULL will signal an error

    Allow struct instantiation to have arguments that set fields
        by order of declaration.  Use must include all arguments, but
        may leave them empty if the default value is desired

        Dog: struct = struct {
            name: string = "Mittens"
            age: int = 3
            length: float = 12.3
        }

        Dog("Bubbles", 23, 1.32)
        Dog(, 23, 1.32)
        Dog(,,) is the same as Dog()

    property names are being added as constants for both OP_GET_PROP
    and OP_SET_PROP, but they aren't really constants.  What other
    way could this be done more clearly.  Interning!!!
        this will also make value comparisons of strings faster
        (right now need to compare lengths + memcmp)

    Does NODE_DECl_VAR only for primitive types, or is it for functions/classes too?
        add ability to assign variables to classes, function, instances

        How about assigning functions to other functions?
            I don't think we support this right now:
            my_fun: () -> = other_fun

    Clear up the warnings (especially with switch statements)

    String Interning

    When a function returns, it closes any upvalues, but we don't
        see the call to OP_CLOSE_UPVALUE - need to add more instructions to
        disassemble chunk OR somehow make returning from a function call
        OP_CLOSE_UPVALUE for clarity.  Is there any situation where
        OP_CLOSE_UPVALUE actually gets called (rather than OP_RETURN 
        just doing all the work?)

    in compiler, CALL and CASCADE CALL share a lot of code - pull that into a function

    Native functions - start with clock() for measuring time
        should have an OP_CALL_NATIVE code

    Having to call free_sig on almost all signatures in compile_node is a bit much
      and super prone to errors.  How about putting all Sig* into a list upon
      creation, and then just free that list when the compilation process is over?
        this is similar to how we deal with freeing Objects with the GC

    Implement deleting from hash table - need to use tombstones

    Intern strings - create a "strings" table in vm

    Test Edge cases by writing toy programs - save these programs as correctness tests

    Stress test by writing script to load nyc_subway data - compare runtime to python pandas

    Write benchmarking code to use with chrome://tracing to find hotspots

    Why are if /else so much slower than just if (think of the fibonacci example


StatementList should be DeclList - all programs are a list of declarations
  decl - classDecl | funDecl | varDecl | stmt
      leave no effect on the stack
  stmt - exprStmt | forStmt | ifStmt | printStmt | returnStmt | whileStmt | block
      exprStmt are expressions where the result is discarded (pop the stack)
  expr - Literal | Unary | Binary | SetVar | GetVar
      push one value on the stack


