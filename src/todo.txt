Syntax highlighter:

    Fill in description.  
        Include link to Github src and Docs for Cebra

    Create simple cebra logo.
        Look sample logos to see what kind is acceptable for extensions

    Publish on VSCode extensions marketplace
        Look at tutorial to see what steps need to be taken

Documentation:
    Look at GifTuna website for simple but effective layout

    Upload logo to website

    Include language specification, eg:
        VarDecl     = "var" ( VarSpec | "(" { VarSpec ";" } ")" ) .
        VarSpec     = IdentifierList ( Type [ "=" ExpressionList ] | "=" ExpressionList ) 

    Clean up colors to make it more simple and clean.

    Update sections titles to match current status

    Update section on how to download/build from source and VSCode syntax highlighter

    Consider looking at Nystrom's Wren to see how he put the interpreter in the browser

    Maybe look into posting it on handmade network/reddit...
        
    Look at Odin-lang for reference for docs
        could just have sample code user can look at rather than an actual interactive panel

Implementation:

    One solution! Only allow sequential assignment as a free standing statement.  
    It's a little more verbose, but it makes syntax clearer
        a, b = returns_two_values()
        takes_two_values(a, b)
        while (true) {
            a, b, = returns_two_values()
            print(a)
        }

        Don't need to touch assignment or any of the expression parsing code now - it currently only
            accepts a single assignment, and will report an error if programmer tries to add more using ','. 

        Change name of parse_var_declaration to parse_sequential.
            parse_sequential will then take care of single/multi declaration and multiassignment
            If it's a single declaration, return that without wrapping in NodeList.  Otherwise
            wrap in nodelist for caller (declaration()) to unwrap and add to the node list.  
            Single assignments are handled by the expression() recursive calls, so no need to worry 
            about those, but can consider refactoring them later.

        if ':=', all left hand sides must be DeclVars with inferred types --- error check
        if '=', left hand sides can be GetVar, GetProp, GetElement OR DeclVars with explicit types --- error check
            when doing functions with multiple returns, need to modify those four nodes to allow
            us to set them to values on the stack after the function call - essentially reverse
            the order of the sequence, and set a flag in the node (or just right == NULL) so
            that the nodes set to the top of the stack without compiling 'right'.  All the 
            set statements also need to be wrapped in a ExprStmt

            three_returns :: () -> (int, int, int) {
                -> 1, 2, 3
            }
        
            eg, a, b: int, c[0] = three_returns()
            make_stmt_expr(make_set_element(get_element [c, 0], right))
            make_stmt_expr(make_decl_var(token [b], NULL))
            make_stmt_expr(make_set_var(get_var [a], NULL))

            Set element will compile the call on 'two_returns', which leaves [1][2][3] on the stack
            set element will then set itself to the top of the stack, 3.  Then the StmtExpr wrapper pops 3
            decl var will set b to the top of the stack, 2,  without compiling (since right is NULL).  Wrapper pops 2
            set var will set a = to top of stack 1.  Wrapper pops 1
            
            a is set to 1
            b is declared and set to 2
            c[0] is set to 3
    
    One solution!  For struct NodeList returns with assignments, ALWAYS wrap all assignment
    Nodes with a StmtExpr EXCEPT for the last one - for that last one, have the caller
    wrap it or leave it.  The only caller that should wrap the last assignment node is 
    declaration(), right?  
        
        Will also need to write a switch case in compile_node to take care of struct NodeList* 
            - this is cleaner and more general than having to unwrap struct NodeList everywhere
            in the parser.  

            When are sequentials used? and wouldn't this syntax overlap with for loop syntax?
                expressions - a, b + 3 (result of b + 3 on stack)
                assignment - a, b = 23, 5 (5 on stack)

    Finishing implementing multiassignments in assignment() function.  

    Wait! What happens if someone writes this:
        if true and x, y = false, true { }
        //when x = false is compiled, it should pop the result from the stack and only
        if true and y = true { } is evaluated

        Wouldn' this mean that ALL functions that may use the multiassignment
        needs to wrap the results in ExprStmt???

        Could this problem be solve by making multiassignment/declaration into
        a special ast node (rather than parsing it into simpiler ast nodes)?
        The struct MultiDecl and MultAssign could have two lists of Tokens + type + right
        or left + right,  and then let the compiler sort out the compilation order???

    Change assignment to new list declarations
        Problem:
            How to deal with user trying to do a double assignment inside condition?
            If it's a list, then the second element is used as the final result
            This allows us to use the second result as a result code if necessary

            cool_function :: (n: int) -> (int, bool) {
                -> n - 1, n > 0
            }

            a := 5
            while a, b, = cool_function(a) {
                print(a) //should print 4, 3, 2, 1, 0
            }

            a, b = 5, 2 //this will wrap each expression in a stmt, popping the results
                need to look at end of expression() - if result is a struct NodeList*, 
                wrap each element in a ExprStmt, and return a new struct NodeList* with
                the newly wrapped nodes

        Assignments will possibly need to be wrapped in a StmtExpr to pop the results.
        Leave that responsibility to the caller of expression() - if they receive a struct NodeList*
        back (it should be full of assignments), then it needs to decide how to wrap each element.
            1. If expression is called in declaration, then all assignments need to be wrapped in ExprStmt.
            2. If expression as part of a condition, then all except the last assignment is wrapped in ExprStmt
            3. If expression is an argument, then none should be wrapped (but the order may need to be reversed???)
            4. Others???


    Add multiple return options to functions
        need to make return type a TypeList
        need to make Return node 'right' a NodeList
        return types must be enclosed in parens now
        fun :: (a: int) -> (int) {
            -> 23
        }
        fun :: (a: int) -> () {
        }
        fun :: (a: int) -> (int, string) {
            -> 23, "dog"
        }

        Implement syntax and test with single returns for now.
        Then expand to test multiple returns with assignments - see below

    Just swap order of variables for multiassignment/multideclaration:
        three_returns ::() -> (int, int, int) {
            i := 0
            -> i = i + 1, i = i + 1, i = i + 1
        }
        a, b, c, d = 10, three_returns()

        if compile right side if NOT function
            a has expr for right, and assigned to top of stack
        compile right side to get a function with three returns
            grab b, c and d and reverse
            d has three_returns() for right and is assigned to top of stack after compiling call on function
            c has NULL for right, and assigned to top of stack
            b has NULL for right, and assigned to top of stack

    'with' statement?   Creates a shadow variable with casted type in new scope, but only does so if cast is valid (not nil)
        //this cuts out 1 indent, and 3 lines compared to using 'when/is' statements
        with expr as PrimaryExpr {
            -> expr.token.literal as float
        }

        with expr as BinaryExpr {
            left := evaluate_expr(expr.left)
            right := evaluate_expr(expr.right)
            when expr.token.literal {
                is "+" { -> left + right }
                is "-" { -> left - right }
                is "*" { -> left * right }
                is "/" { -> left / right }
            }
        }

    'break' and 'continue' for loops

    Rewrite Lexer - it's very messy and error prone
        consider writing simple c program that reads in and tokenizes text
        then the program can count tokens to make sure it all adds up
            this would help us know if any changes to the lexer are breaking shit

    Write tests for multi-variable assignment

    Write code for multi-variable returns

    Write code for using multi-variable returns as argument into multi-parameter function
        fun_ret_two :: () -> (int, int) {
        }
        fun_two_params :: (a: int, b: int) -> {
        }
        fun_two_params(fun_ret_two())

    //this is super messy, but paren grouping is necessary to avoid ambiguous return/function relationships
    //a single return is NOT wrapped in parens
        fun :: () -> int {}
        fun :: () -> (int, string) {}
        fun :: () -> (()-> (int, int), ()-> int) {

        }

    Get it parsing
    Get it compiling
    Get it running

    For function types, no take in a TypeArray for returns too
    ret_types during compilation now also need to return TypeArrays
    while parsing, need to redo make_decl_fun to include multiple returns
        and when parsing return statements do the same
    May need to include more info for ObjFun too (right now we have arity, but
        may require return count too)
    
    Need multiple returns for easy file reading
        str, result := read(f) //where read returns a string and boolean where boolean is false if failed

    Reading/Writing to files.  How does python do this?  (or look at other languages)
        consider adding in \n for print() for more flexible ways to output data.

        Maybe generalize reading/writing?
       
        f: file = open("test.txt") //will automatically close with GC?  If so, need to make a runtime representation (ObjFile)
        src := read(f)

        a := read(stdin)
        b := read(file) //read entire file until end
        c := readln(file) //read one line up to, and including, \n
        write("Hello world", stdout)
        write("Hello world", f)

    'import' keyword and importing modules (do this once I have enough native functions to require it)
        how does python, ruby and others do this?
        what is a module?  Structs, Enums and Functions?  
        how should namespaces work (if we decide to use them)
        should native functions be imported?  Or are they always included?

        import "Parser.cbr"
        import "Lexer.cbr"
        import "Evaluator.cbr"

        src := "12 - 23 / 4"
        tokens := scan_source(src)
        ast := parser_tokens(tokens)
        print(evaluate_ast(ast))

    Sockets for TCP and UDP connections - we just want a high level wrapper over the same
        functionality.  Allow the user to create sockets and send bytes (or strings, floats, ints)
    
    Strings are interned.  Since interned strings are only used to removed repeated strings, they shouldn't be marked as a root.  Then
        after all references are traced but before sweeping, we should delete interned string pointers from 
        the hash table that are not marked.  Will need to implement delete entries in a table for this.

    Wrap push(vm, value) in a macro that returns /adds error if above stack limit
        how about when push_root() is over stack limit???

    Allowing struct instantiation in fields, BUT check if there are circular instantiations and show error
        if so.

    Write script to build using both Clang and MSVC, and then run correctness.cbr and interpreter.cbr
    for both executables all in one go.

    Update website for Cebra with new syntax/sections.
        How to download/build src is the most important
            include which compilers + versions tested on and cmake versions
        Don't worry about syntax highlighting for now - can add prism.js later (or other)

    Read:
        The Slightly Disgruntled Scientist tutorial on debugguers - Valgrind and GBD: Tame the Wild C
            https://heeris.id.au/2016/valgrind-gdb/
            
            Example 1: Uninitialized variabls
                Valgrind runs program on synthetic processer. GDB is debugger with breakpoints, single stepping, etc
                run program in Valgrind with any arguments using --vgdb-error=0 flag to allow using GDB
                    use command output by valgrind to run GDB with the currently running program
                can then step through program using GDB, and also send commands to valgrind using 'monitor'
                consider making a 'wat' command to combine address, size, + valgrind command get_vbits into one command
            Chapter 2: Memory leaks

    Test compiling on Windows FOR Linux, and on Linux FOR Windows to see how that works.

    Error messages in compiler are all messed up in compiler.c.  In NODE_FUN, when returning after error sometimes
        the errors in func_comp aren't copied over to the enclosing compiler before func_comp is freed.
        ALSO, on errors func_comp is NOT freed, so the compiler chain isn't reset back to the enclosing compiler
        losing error messages...

    Setting globals in compiler/parser is using the same code 4 times (for enum/struct/fun declaration in
        parser and in define_native() in compiler).  Combine into a single function in compiler called
        add_global(struct Table* globals, struct ObjString*, struct Type* type) and do any checks in there
            will need to make parser/compiler errors compatible if we want to use the same function for both

    Real Problem: Errors didn't stop compilation, which triggered more errors and breaking everything.
        right now we are returning immediately if there is a compilation error of
        one of the nodes.  This cuts things short but at least it works.  Need to figure out a way
        to handle errors - when an error occurs and compile_node returns, any pushed roots or new
        compilers, etc don't get freed, causing the compiler to go into an invalid state.  This then
        triggers problems with GC, etc.

    Continue writing basic interpreter - add any errors below and fix them afterwards
        big problem: we need to access parse_expression() in parse_primary(), but
        the declaration needs to come after....

        will need to do two passes to solve this problem: first pass resolves all :: notation - 
            struct, enum, function declarations. 

            The first pass could shove all that into a global table - then we can access them
            as needed during the second pass when all other code is compiled

    need to make runtime errors leave stack/OpPtr in valid state so that
        more errors can be found during runtime (currently only done for OP_GET_PROP and OP_SET_PROP)
        Add lines to runtime errors... could we emit line numbers along with Ops?
        maybe add compilation errors before doing the runtime ones

    Set memory limit by using system call setrlimit() so that I can put in guards for when memory
        runs out.

    Make function to convert char to ASCII, or allow char (and string?) comparisons using <, <=, >, >=

    Can value_arrary.h/c be merged into value.h/c?

    struct Error (in parser.h) is a general error, and can be used for both the compiler and vm
        get rid of ComilerError and RuntimeError

    'consume' in parser is too general and doesn't allow specific error messages - replacing it with match() + ADD_ERROR will be better
        but it's a lot more verbose

    Need to deal with c-errors too (snprintf, reading from file, etc)
    
    put in 'if' into correctness.cbr to turn on/off tests - this will make it easier to
        pinpoint failing tests/crashing tests
        this doesn't work!!! Need a preprocesser to remove/add/replace code

    type() function that returns 'int', 'string', 'bool', 'float', 'Dog', '(int) -> string' in string format

    change name of TOKEN_STRING_TYPE to TOKEN_STRING_IDENTIFIER so that it can
        be used for both type AND casting to strings

    write code to catch compiler errors: pretty much type checking
        compiling error - if the condition evaulates to non-boolean take care of
            any memory

    'Variable must be assigned to a valid expression' in parser should tell user the variable identifier
        need a way for errors to print token too

    Write code to catch runtime errors: what runtime checks do we do?

    Write code to break maximum parameter/argument, upvalues, and constants limits

    Compile to webassembly and run in browser
        test with simple 'hello world' program first
        test with program that reads in text from text box (our script)
            and returns info about that text
        integrate final code

    Update documentation to include new syntax + List/Map
        and include small box to write /run test scripts

    Write broken code and make sure ALL parsing, compilation, and runtime
        errors are caught.  Make 3 new files: parsing.cbr, compiling.cbr, 
        runtime.cbr with bad code.  Make sure that all mistakes sychronize
        and run to the very end, emitting errors WITHOUT crashing.

    Add string manipulation
        access char by index using [idx]
        property size
        slicing by index [0, 2]

    find python native function list (for early python versions)
        and add those functions
        copy() for instances/lists/maps
        casting to string/int/float

    How about letting declarations leave NIL on the stack, and then 
    popping them off by wrapping them in expr_stmt?  This would
    get rid of the weird NIL checking in OP_POP.

        had bug before where setting a variable to nil and 
        return nil as the type (which didn't get popped)
        changed code so that variable signature was returned

    Need to add parse error if quote is not closed (rather than quietly failing)
        and program crashing

    Need to make parser and compiler errors NOT fail silently and instead
        give user a useful message. Will require more careful handling of
        parse/compiler/runtime errors - including syncing so that multiple
        errors can be shown

    Implement deleting from hash table - need to use tombstones

    Intern strings - create a "strings" table in vm

    Write benchmarking code to use with chrome://tracing to find hotspots

    Why are if /else so much slower than just if (think of the fibonacci example)


StatementList should be DeclList - all programs are a list of declarations
  decl - classDecl | funDecl | varDecl | stmt
      leave no effect on the stack
  stmt - exprStmt | forStmt | ifStmt | printStmt | returnStmt | whileStmt | block
      exprStmt are expressions where the result is discarded (pop the stack)
  expr - Literal | Unary | Binary | SetVar | GetVar
      push one value on the stack


