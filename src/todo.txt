DOCUMENTATION:
    Look at how Nystrom design docs for Wren
    The embedded compiler/vm in browser is neat

ADDING FEATURES:
    Add correctness tests for new features
    Pass all correctness.cbr tests
    Check that ALL memory is freed if GC is called at end of main()
    TODO: need a way to test type checking

IMPLEMENTATION:

Dog: class = class {
    name: string = "Mittens"
    age: int = 3
    length: float = 100.2
}

make_dog: () -> Dog = () -> Dog {
    dog: Dog = Dog()
    -> dog
}

print make_dog().name
d: Dog = make_dog()


c: () -> (int) -> int = () -> (int) -> int {
    d: (int) -> int = (n: int) -> int {
        -> n * 2
    }
    -> d
}

make_get_prop should have two parameters, struct Node* inst and Token prop

GetProp - get instance identifier, then follow that up with an arbitrary number of
        TOKEN_DOT + TOKEN_IDENTIFIER.  Emit a bunch of OP_GET_PROP.  
        BUT, if TOKEN_DOT + TOKEN_IDENTIFIER is followed by TOKEN_EQUAL, then
        put it inside an OP_SET_PROP instead (the left side should be an instance)

        Note: The first parameter is a struct Node* (GetVar)
            and the second is a Token prop
        struct Node* inst = make_get_prop(instance, prop)
        make_get_prop(inst, prop), 
        make_set_prop(instance, prop, value)

Call - GetVar or GetProp (can't set function to a value, no no SetVar or SetProp), followed
        by a variable number of calls (parentheses with arguments)
        dog.bark()()(), or dog.mouth.bark()(), bark()(), bark()


//problem: printing the result of c(), when it shoud be printing result of c()(4)
//  could have Call take in multiple lists of arguments (and no token)
//  and also make identifiers for functions just be a GET_LOCAL 
print c()(4)

    could make SetVar take in two Node* - left and right, where right is an expression as usual,
        and left is simply a GetVar* node with the token corresponding the variable.  This can
        then be taken out during compilation of SetVar*.  This would let us get rid of the 
        free_node call in parser - which is messy since we don't free nodes in the parser normally

    //problem: printing the result of c(), when it shoud be printing result of c()(4)
        parser seeing that declaration as a print c(), and then a separate (4) declaration
    //  could have Call take in multiple lists of arguments (and no token) since
            all the cascading calls have to be called together as a single expression
            when calling a function, set compiler->previous_fun_sig if NULL
            and then set set to NULL after all cascades are done
    //  and just put the function on the stack using GET_LOCAL/GET_UPVALUE
    print c()(4)

    constructors
        both these ways of calling make_dog should work:
        try tracing to see what works.
            make_dog: () -> Dog {
                dog: Dog = Dog()
                -> dog
            }
            print make_dog().name
            d: Dog = make_dog()

        for the print statement, we currently don't support
        dot notation with return values from function calls.
        NOTE: currently breaks in parser - specifically in call_expression()
            need to be able to recognize dot notation (for both setting/getting)
            with function calls and cascading function calls

            should try to simplify calls and cascading calls like so:
            a()()("dog", 3): if an identifier is there ('a'), then call that function
            if no identifier (for second and third call), call the function currently
            on the stack with the given arguments.  Change NODE_CASCADE with just
            the arguments.  NODE_CALL, NODE_CASCADE, NODE_CASCADE

                Just use NODE_CALL, but set Token name to a null value (start is NULL, an length = 0)
                for cascading calls

            Do the same with properties and dot notation.  dog.name should be two
            nodes: NODE_GET_LOCAL (dog) and then NODE_GET_PROP(.name). 

            This will allow the same notation use with functions too:
            a().name will be a() followed by a property getter/setter .name
            NODE_CALL, NODE_GET_PROP

        for the variable declaration, classes, instances and functions
        are not currently supported.

    property names are being added as constants for both OP_GET_PROP
    and OP_SET_PROP, but they aren't really constants.  What other
    way could this be done more clearly.  Interning!!!

    add methods
        copy_value(Value* value) - 
            add functions/classes/instances for better class instances

    Inheritance syntax and implementation
        fill out the rest of copy_value(Value* value) for class methods

    Does NODE_DECl_VAR only for primitive types, or is it for functions/classes too?
        add ability to assign variables to classes, function, instances

        How about assigning functions to other functions?
            I don't think we support this right now:
            my_fun: () -> = other_fun

    Allow shorthand for declaration types:
        a := 1
        b := "dogg"
        c := () -> int {
            -> 3
        }
        Dog := class {
            name := "Mittens"
        }

    Clear up the warnings (especially with switch statements)

    String Interning

    When a function returns, it closes any upvalues, but we don't
        see the call to OP_CLOSE_UPVALUE - need to add more instructions to
        disassemble chunk OR somehow make returning from a function call
        OP_CLOSE_UPVALUE for clarity.  Is there any situation where
        OP_CLOSE_UPVALUE actually gets called (rather than OP_RETURN 
        just doing all the work?)

    in compiler, CALL and CASCADE CALL share a lot of code - pull that into a function

    Native functions - start with clock() for measuring time
        should have an OP_CALL_NATIVE code

    Having to call free_sig on almost all signatures in compile_node is a bit much
      and super prone to errors.  How about putting all Sig* into a list upon
      creation, and then just free that list when the compilation process is over?
        this is similar to how we deal with freeing Objects with the GC

    Implement deleting from hash table - need to use tombstones

    Intern strings - create a "strings" table in vm

    Test Edge cases by writing toy programs - save these programs as correctness tests

    Stress test by writing script to load nyc_subway data - compare runtime to python pandas

    Write benchmarking code to use with chrome://tracing to find hotspots

    Why are if /else so much slower than just if (think of the fibonacci example


StatementList should be DeclList - all programs are a list of declarations
  decl - classDecl | funDecl | varDecl | stmt
      leave no effect on the stack
  stmt - exprStmt | forStmt | ifStmt | printStmt | returnStmt | whileStmt | block
      exprStmt are expressions where the result is discarded (pop the stack)
  expr - Literal | Unary | Binary | SetVar | GetVar
      push one value on the stack


