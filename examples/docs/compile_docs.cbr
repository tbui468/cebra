dir := "C:\\dev\\cebra\\examples\\docs\\"

//combine html files

f := open(dir + "cebra_docs.html")

out := open(dir + "compiled_docs.html")
clear(out)

while !eof(f) {
    s := read_line(f)
    if s.size > 0 and s[0] == "$"{
        about_f := open(dir + s[1, s.size])
        about_s := read_all(about_f)
        append(out, about_s + "\n")
        close(about_f)
    } else {
        append(out, s + "\n")
    } 
}

close(f)
close(out)

//highlight compiled_docs.html

f = open(dir + "compiled_docs.html")
out = open(dir + "final_docs.html")
clear(out)

code_block := false
while !eof(f) {
    line := read_line(f)

    if start_code(line)    code_block = true
    if end_code(line)      code_block = false

    if code_block {
        line = highlight_string(line)
    }

    append(out, line + "\n")
}

close(f)
close(out)

Mode :: enum {
    STRING
    COMMENT
    IDENTIFIER
    NONE
}

Highlight :: struct {
    start := -1
    end := -1
    color := ""
}

keywords := Map<bool>()
keywords["for"] = true
keywords["if"] = true

is_alpha :: (s: string) -> (bool) {
    -> s == "a" or s == "A" or 
       s == "b" or s == "B" or 
       s == "c" or s == "C" or 
       s == "d" or s == "D" or 
       s == "e" or s == "E" or 
       s == "f" or s == "F" or 
       s == "g" or s == "G" or 
       s == "h" or s == "H" or 
       s == "i" or s == "I" or 
       s == "j" or s == "J" or 
       s == "k" or s == "K" or 
       s == "l" or s == "L" or 
       s == "m" or s == "M" or 
       s == "n" or s == "N" or 
       s == "o" or s == "O" or 
       s == "p" or s == "P" or 
       s == "q" or s == "Q" or 
       s == "r" or s == "R" or 
       s == "s" or s == "S" or 
       s == "t" or s == "T" or 
       s == "u" or s == "U" or 
       s == "v" or s == "V" or 
       s == "w" or s == "W" or 
       s == "x" or s == "X" or 
       s == "y" or s == "Y" or 
       s == "z" or s == "Z"
}

highlight_string :: (s: string) -> (string) {
    //loop through string once and create Highlight objects and put it into a
    //list.  At the end, loop through the list and apply the css tags
    mode := Mode.NONE
    start := -1
    end := -1
    dq := "\""[1, 2]

    highlights := List<Highlight>()
    highlights.size = 0

    i := 0
    while i < s.size {
        when mode {
            is Mode.NONE {
                if i > 0 and s[i-1] == "/" and s[i] == "/" {
                    h := Highlight()
                    h.start = i - 1
                    h.end = s.size - 1
                    h.color = "gr"
                    highlights[highlights.size] = h
                    //highlights.size = highlights.size + 1
                    i = s.size - 1 //skipping remainder of string
                }
                if s[i] == dq {
                    mode = Mode.STRING
                    start = i
                }
                //if is_alpha(s[i]) {
                    //mode = Mode.IDENTIFIER
                    //start = i
               // }
            }
            is Mode.STRING {
                if s[i] == dq {
                    mode = Mode.NONE
                    h := Highlight()
                    h.start = start
                    h.end = i
                    h.color = "re"
                    highlights[highlights.size] = h
                    //highlights.size = highlights.size + 1
                } 
            }
            is Mode.IDENTIFIER {
                //if s[i] == " " or i == s.size - 1 {
                //    mode = Mode.NONE
                 //   h := Highlight()
                 //   h.start = start
                 //   h.end = i - 1
                 //   h.color = "bl"
                 //   highlights[highlights.size] = h
               // }
            }
        }
        i = i + 1
    }


    {
        result := ""
        start := 0
        for i := 0, i < highlights.size, i = i + 1 {
            result = result + s[start, highlights[i].start] + "<span class=\"" + highlights[i].color + "\">" + s[highlights[i].start, highlights[i].end + 1] + "</span>"
            start = highlights[i].end + 1
        }
        -> result + s[start, s.size]
    }
}


start_code :: (s: string) -> (bool) {
  trimmed := remove_starting_whitespace(s)
  -> trimmed.size >= 6 and trimmed[0, 6] == "<code>"
}

end_code :: (s: string) -> (bool) {
  trimmed := remove_starting_whitespace(s)
  -> trimmed.size >= 7 and trimmed[0, 7] == "</code>"
}

remove_starting_whitespace :: (s: string) -> (string) {
    i := 0
    while i < s.size - 1 and s[i] == " " {
        i = i + 1
    }
    -> s[i,s.size]
}
